# Pytania z egzaminu 2021

## Opisz krótko różnicę pomiędzy katalogiem a tablicą stron.

Katalog stron jest strukturą używaną w mechanizmach zarządzania pamięcią, gdzie wskazuje na tablice stron, które z kolei zawierają informacje o mapowaniu wirtualnych adresów pamięci na fizyczne adresy. Katalog stron jest pierwszym poziomem, a tablica stron drugim poziomem mapowania.

## Wymień i krótko opisz możliwe stany linii w modelu spójności.

Możliwe stany linii w modelu spójności obejmują:

- **Zmodyfikowany (Modified)**: Linia jest aktualna i zmodyfikowana, tylko w pamięci podręcznej danego procesora.
- **Wyłączony (Exclusive)**: Linia jest aktualna i jedyna w pamięci podręcznej danego procesora.
- **Udostępniony (Shared)**: Linia jest aktualna i może być w pamięci podręcznej wielu procesorów.
- **Nieważny (Invalid)**: Linia jest nieważna, nie zawiera aktualnych danych.

## Czym charakteryzują się instrukcje serializujące w architekturze x86? Podaj przykład takich instrukcji.

Instrukcje serializujące zapewniają, że wszystkie poprzednie instrukcje zostały zakończone, a wszystkie zmiany w pamięci są widoczne, zanim jakakolwiek kolejna instrukcja zostanie wykonana. Przykładem jest instrukcja **CPUID**.

## Jakie działania należy podjąć w przypadku wystąpienia błędu braku strony?

Działania w przypadku błędu braku strony obejmują:

1. Sprawdzenie, czy adres strony jest prawidłowy.
2. Załadowanie brakującej strony z pamięci masowej do pamięci operacyjnej.
3. Aktualizacja tablicy stron, aby wskazywała na nowo załadowaną stronę.
4. Ponowne wykonanie instrukcji, która spowodowała błąd braku strony.

## Podaj przykład braku ortogonalności w dowolnej architekturze komputera.

Brak ortogonalności może wystąpić, gdy pewne operacje nie są dostępne dla wszystkich typów danych lub rejestrów. Na przykład w architekturze x86, nie wszystkie instrukcje mogą być używane z wszystkimi rejestrami, np. instrukcja **MUL** może mieć ograniczenia co do używanych rejestrów.

## Wymień i krótko opisz klasy pamięci rozróżniane ze względu na sposób adresowania (metodę wyboru słowa z pamięci).

Klasy pamięci według sposobu adresowania obejmują:

- **Pamięć bezpośredniego dostępu (RAM)**: Każde słowo pamięci ma unikalny adres, dostęp jest szybki i bezpośredni.
- **Pamięć asocjacyjna (CAM)**: Adresowanie na podstawie zawartości, wykorzystywana w szybkich tablicach tłumaczeń adresów.
- **Pamięć sekwencyjna**: Adresowanie w sposób sekwencyjny, jak w taśmach magnetycznych.

## Na czym polega różnica pomiędzy fragmentacją zewnętrzną a wewnętrzną? Podaj przykłady sytuacji, w których te fragmentacje się pojawiają.

Fragmentacja zewnętrzna występuje, gdy wolna pamięć jest podzielona na małe, nieciągłe bloki, co uniemożliwia przydzielenie dużego bloku pamięci. Przykład: systemy alokacji pamięci o zmiennej wielkości bloków.
Fragmentacja wewnętrzna występuje, gdy przydzielone bloki pamięci są większe niż potrzebne, co prowadzi do marnowania miejsca. Przykład: systemy alokacji pamięci o stałej wielkości bloków.

## Czym przerwania różnią się od wyjątków?

Przerwania są asynchroniczne i mogą wystąpić w dowolnym momencie w wyniku działania urządzeń zewnętrznych. Wyjątki są synchroniczne i występują jako bezpośredni rezultat wykonania instrukcji procesora, np. dzielenie przez zero.

## Wymień i krótko opisz klasy możliwych argumentów instrukcji dostępnych w architekturze x86.

Klasy argumentów instrukcji w x86 obejmują:

- **Natychmiastowe**: Stałe wartości zawarte bezpośrednio w instrukcji.
- **Rejestrowe**: Wskazują na rejestry procesora.
- **Pamięciowe**: Adresy w pamięci.
- **Przesunięcia**: Wartości wykorzystywane do obliczeń adresów.

## Wymień i krótko opisz algorytmy uprzedzającego (antycypowanego) pobierania danych.

Algorytmy antycypowanego pobierania danych obejmują:

- **Sekwencyjne pobieranie**: Pobieranie kolejnych bloków danych zgodnie z przewidywanym ciągiem dostępu.
- **Pobieranie na żądanie**: Pobieranie danych, które prawdopodobnie będą wkrótce potrzebne.
- **Pobieranie oparte na wzorcach**: Analiza poprzednich dostępów do danych i przewidywanie przyszłych.

## Wymień i krótko opisz najczęściej używane flagi dostępne w rejestrze flag architektury x86.

Najczęściej używane flagi w rejestrze flag x86 obejmują:

- **Carry Flag (CF)**: Ustawiana, gdy wynik operacji arytmetycznej jest za duży dla rejestru.
- **Zero Flag (ZF)**: Ustawiana, gdy wynik operacji arytmetycznej jest równy zero.
- **Sign Flag (SF)**: Ustawiana, gdy wynik operacji arytmetycznej jest ujemny.
- **Overflow Flag (OF)**: Ustawiana, gdy wynik operacji arytmetycznej przekracza zakres liczb dodatnich/ujemnych.

## Wymień główne elementy modelu komputera z programem przechowywanym i podaj odpowiadające im elementy modelu maszyny Turinga.

Główne elementy modelu komputera z programem przechowywanym:

- **Pamięć**: Taśma maszyny Turinga.
- **Jednostka sterująca**: Głowica odczytująca/zapisująca maszyny Turinga.
- **Rejestry**: Stan maszyny Turinga.

## Wymień i krótko opisz elementy składni języka asemblera.

Elementy składni języka asemblera obejmują:

- **Mnemoniki**: Skróty instrukcji maszynowych (np. MOV, ADD).
- **Argumenty**: Rejestry, wartości natychmiastowe, adresy pamięci.
- **Dyrektywy**: Instrukcje dla asemblera (np. SEGMENT, END).
- **Komentarze**: Opisy kodu dla programistów, ignorowane przez asembler.

## Wymień i krótko opisz różnice między architekturami RISC i CISC.

Różnice między RISC i CISC:

- **RISC (Reduced Instruction Set Computing)**: Mała liczba prostych instrukcji, szybkie wykonanie.
- **CISC (Complex Instruction Set Computing)**: Duża liczba złożonych instrukcji, wolniejsze wykonanie, ale mniej instrukcji potrzebnych do wykonania zadania.

## Opisz krótko zjawisko szamotania.

Szamotanie (thrashing) występuje, gdy system operacyjny zbyt często wymienia strony pamięci między RAM a dyskiem, co prowadzi do znacznego spadku wydajności.

## Opisz krótko strukturę ramki stosu zdefiniowanej w ABI Systemu V dla architektury x86.

Struktura ramki stosu w ABI Systemu V dla x86 zawiera:

- **Adres powrotu**: Adres, do którego wraca program po zakończeniu funkcji.
- **Stare wartości rejestrów**: Zapisane wartości rejestrów, które funkcja zmienia.
- **Lokalne zmienne**: Przestrzeń na zmienne lokalne funkcji.
- **Argumenty funkcji**: Przekazane parametry do wywołanej funkcji.

## Opisz krótko różnicę pomiędzy przerwaniem precyzyjnym a nieprecyzyjnym.

Przerwanie precyzyjne występuje, gdy stan procesora jest dokładnie znany i można go przywrócić do momentu przed przerwaniem. Przerwanie nieprecyzyjne występuje, gdy niektóre instrukcje zostały już częściowo wykonane, co utrudnia przywrócenie dokładnego stanu.

## Wady i zalety odwróconej tablicy stron.

**Zalety**:

- Mniejsza liczba wpisów w tablicy stron.
- Lepsze zarządzanie dużą ilością pamięci.

**Wady**:

- Wolniejsze wyszukiwanie stron.
- Potrzeba dodatkowych struktur danych do zarządzania stronami.

## Jaka jest maksymalna wydajność potoku w procesorze superpotokowym? Uzasadnij.

Maksymalna wydajność potoku w procesorze superpotokowym wynosi jedna instrukcja na cykl zegara, przy założeniu, że nie ma zależności danych ani innych opóźnień.

## Wymień i opisz sprzętowe mechanizmy umożliwiające bądź przyspieszające zarządzanie i ochronę pamięci w systemach komputerowych.

Sprzętowe mechanizmy obejmują:

- **MMU (Memory Management Unit)**: Przetwarza adresy logiczne na fizyczne, zarządza tablicami stron.
- **TLB (Translation Lookaside Buffer)**: Bufor szybkiego dostępu do przetłumaczonych adresów stron.
- **Zabezpieczenia pamięci**: Mechanizmy ochrony przed nieautoryzowanym dostępem do pamięci, np. bit ochrony strony.

## Wymień i opisz sekcje programu w składni AT&T.

Sekcje programu w składni AT&T obejmują:

- **.text**: Kod wykonywalny programu.
- **.data**: Zainicjowane dane statyczne.
- **.bss**: Niezainicjowane dane statyczne.
- **.rodata**: Dane tylko do odczytu.

## Dana jest implementacja algorytmu, w której pobranie danych zajmuje 1/8 czasu uruchomienia na jednym procesorze, a pozostała część może być trywialnie zrównoleglona. Podaj (np. w formie wyrażenia arytmetycznego) maksymalne przyspieszenie na maszynie równoległej zakładając stały rozmiar problemu. Uzasadnij.

Maksymalne przyspieszenie można obliczyć na podstawie prawa Amdahla. Jeśli 1/8 czasu nie można zrównoleglić, maksymalne przyspieszenie \(S\) dla \(N\) procesorów wynosi:
\[ S = \frac{1}{\frac{1}{8} + \frac{7}{8N}} \]

## Opisz sposób obliczania adresu w pamięci i wymień wszystkie elementy, na podstawie których to przesunięcie jest obliczane. Używając składni AT&T zapisz przykładowy argument wykorzystujący taki sposób określenia lokacji argumentu.

Adres w pamięci w składni AT&T oblicza się jako:
\[ \text{Adres} = \text{bazowy rejestr} + \text{indeksowy rejestr} \times \text{skala} + \text{przesunięcie} \]
Przykładowy argument: `(%ebx, %esi, 4, 8)`, co oznacza: `Adres = %ebx + %esi \times 4 + 8`.

## Wymień i opisz sytuacje, w których linia pamięci podręcznej zostanie wypełniona.

Linia pamięci podręcznej zostanie wypełniona, gdy:

- **Brak trafienia w cache**: Dane nie są w pamięci podręcznej.
- **Wstępne pobieranie**: Dane są przewidywane jako potrzebne.
- **Kohorentność cache**: Aktualizacja danych w celu utrzymania spójności między cache a pamięcią główną.

## Wymień i opisz rejestry ogólnego przeznaczenia w architekturze x86.

Rejestry ogólnego przeznaczenia w x86 obejmują:

- **EAX**: Akumulator do operacji arytmetycznych.
- **EBX**: Rejestr bazowy.
- **ECX**: Rejestr licznika, używany w operacjach iteracyjnych.
- **EDX**: Rejestr danych, używany w operacjach wejścia/wyjścia.
- **ESI**: Rejestr źródłowy indeksu.
- **EDI**: Rejestr docelowy indeksu.
- **EBP**: Rejestr bazowy stosu.
- **ESP**: Rejestr wskaźnika stosu.

## Opisz możliwe zmiany stanu linii wraz z sytuacjami (warunkami), w których zachodzą, w protokole MESI i trybie WT.

Zmiany stanu linii w protokole MESI:

- **Modified do Shared**: Inny procesor żąda odczytu linii.
- **Exclusive do Shared**: Inny procesor żąda odczytu linii.
- **Shared do Invalid**: Inny procesor żąda zapisu linii.
  Zmiany stanu w trybie Write-Through (WT):
- **Write-through zawsze zapisuje dane bezpośrednio do pamięci**: Nie zmienia stanu linii w cache, ale zawsze aktualizuje pamięć główną.

## Wymień i opisz metody kontroli pamięci podręcznej z poziomu programu.

Metody kontroli pamięci podręcznej obejmują:

- **Instrukcje PREFETCH**: Przewidywanie danych i ładowanie ich do cache.
- **Instrukcje CLFLUSH**: Czyszczenie konkretnej linii cache.
- **Ustawienia polityki cache**: Programowa konfiguracja sposobu zarządzania danymi w cache, np. Write-Through, Write-Back.

## Opisz różnice pomiędzy skalowaniem silnym a słabym.

Skalowanie silne oznacza zwiększenie liczby procesorów przy stałym rozmiarze problemu, podczas gdy skalowanie słabe oznacza zwiększenie liczby procesorów wraz ze wzrostem rozmiaru problemu. Skalowanie silne ocenia wydajność w kontekście stałego problemu, a skalowanie słabe w kontekście rosnącego problemu.

## Wymień i opisz rodzaje konfliktów danych.

Rodzaje konfliktów danych obejmują:

- **Read-After-Write (RAW)**: Przeczytanie danych przed ich zapisaniem.
- **Write-After-Read (WAR)**: Zapisanie danych po ich przeczytaniu.
- **Write-After-Write (WAW)**: Zapisanie danych po wcześniejszym ich zapisaniu.

## Wymień i opisz rodzaje nadmiaru, które należy wprowadzić do systemu w celu poprawy jego niezawodności.

Rodzaje nadmiaru obejmują:

- **Nadmiar sprzętowy**: Duplikacja elementów sprzętowych, np. zasilacze, dyski (RAID).
- **Nadmiar czasowy**: Powtórzenie operacji w celu weryfikacji wyników.
- **Nadmiar informacyjny**: Kodowanie danych w celu wykrycia i korekcji błędów, np. kody ECC.
